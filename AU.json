const { app, BrowserWindow, Tray, Menu, screen, net, dialog, nativeImage, globalShortcut } = require('electron');
const path = require('path');
const fs = require('fs');

let win;
let tray;
let config = {};
let isAnimating = false;

app.name = 'Nuro';

const configPath = path.join(app.getPath('userData'), 'config.json');

function loadConfig() {
    try {
        if (fs.existsSync(configPath)) {
            const configData = fs.readFileSync(configPath, 'utf8');
            return JSON.parse(configData);
        }
    } catch (error) {
        console.error('Error loading config:', error);
    }
    return { width: 400, side: 'right', pinned: false };
}

function saveConfig(newConfig) {
    try {
        config = { ...config, ...newConfig };
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    } catch (error) {
        console.error('Error saving config:', error);
    }
}

function createTrayIcon() {
    const image = nativeImage.createFromPath(path.join(__dirname, 'Nuro-Icon2.ico'));
    return image.resize({ width: 16, height: 16 });
}

function fetchConfig() {
    return new Promise((resolve) => {
        const request = net.request('https://raw.githubusercontent.com/ECCSco/Nuro_Configuration/refs/heads/main/config.json');
        request.on('response', (response) => {
            let data = '';
            response.on('data', (chunk) => {
                data += chunk;
            });
            response.on('end', () => {
                resolve(data.trim());
            });
        });
        request.on('error', () => resolve(null));
        request.end();
    });
}

function fetchURL(url) {
    return new Promise((resolve) => {
        const request = net.request(url);
        request.on('response', (response) => {
            let data = '';
            response.on('data', (chunk) => {
                data += chunk;
            });
            response.on('end', () => {
                resolve(data.trim());
            });
        });
        request.on('error', () => resolve(null));
        request.end();
    });
}

function showConnectionError() {
    dialog.showMessageBoxSync({
        type: 'error',
        title: 'Ошибка подключения',
        message: 'Сервис временно недоступен',
        detail: 'Приносим извинения за неудобства. Пожалуйста, повторите попытку позже.',
        buttons: ['Ок'],
        defaultId: 0,
        noLink: true,
        icon: path.join(__dirname, 'NuroIcon.ico')
    });
    
    app.isQuitting = true;
    app.quit();
}

function showCustomNotification(title, message) {
    if (!win || win.isDestroyed()) {
        return;
    }

    if (!win.isVisible() || win.isMinimized()) {
        win.show();
        win.focus();
    }

    win.webContents.executeJavaScript(`
        (function() {
            const notification = document.createElement('div');
            notification.style.cssText = \`
                position: fixed;
                top: 50px;
                right: 20px;
                background: rgba(255, 255, 255, 0.1);
                color: white;
                padding: 15px 20px;
                border-radius: 12px;
                z-index: 10000;
                font-family: Arial, sans-serif;
                font-size: 14px;
                max-width: 300px;
                backdrop-filter: blur(20px) saturate(180%);
                -webkit-backdrop-filter: blur(20px) saturate(180%);
                border: 1px solid rgba(255, 255, 255, 0.2);
                animation: slideIn 0.3s ease-out;
                box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.36);
            \`;
            
            const titleEl = document.createElement('div');
            titleEl.style.cssText = \`
                font-weight: bold;
                margin-bottom: 5px;
                font-size: 16px;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            \`;
            titleEl.textContent = \`${title}\`;
            
            const messageEl = document.createElement('div');
            messageEl.style.cssText = \`
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            \`;
            messageEl.textContent = \`${message}\`;
            
            notification.appendChild(titleEl);
            notification.appendChild(messageEl);
            
            const style = document.createElement('style');
            style.textContent = \`
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            \`;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideIn 0.3s ease-out reverse';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }
            }, 4000);
        })();
    `).catch(() => {});
}

async function checkForUpdates(silent = false) {
    try {
        const mainJsPath = path.join(process.resourcesPath, 'app', 'main.js');
        
        if (!fs.existsSync(mainJsPath)) return false;

        const currentContent = fs.readFileSync(mainJsPath, 'utf8');
        const githubContent = await fetchURL('https://raw.githubusercontent.com/ECCSco/Nuro_Configuration/refs/heads/main/AU.json');

        if (githubContent && currentContent !== githubContent) {
            fs.writeFileSync(mainJsPath, githubContent);
            
            if (!silent) {
                showCustomNotification('Nuro', 'Программа была успешно обновлена');
            }
            
            app.relaunch();
            app.exit();
            return true;
        } else if (!silent) {
            showCustomNotification('Nuro', 'Обновлений не найдено');
        }
    } catch (error) {
        console.error('Error checking for updates:', error);
        if (!silent) {
            showCustomNotification('Nuro', 'Не удалось проверить обновления');
        }
    }
    return false;
}

function setAutoLaunch(value) {
    app.setLoginItemSettings({
        openAtLogin: value,
        path: app.getPath('exe')
    });
    saveConfig({ runAtStartup: value });
}

function getWindowPosition() {
    const display = screen.getPrimaryDisplay();
    const { workArea } = display;
    
    const width = config.width || 400;
    const side = config.side || 'right';
    
    let x;
    if (side === 'right') {
        x = workArea.x + workArea.width;
    } else {
        x = workArea.x - width;
    }

    return {
        x: x,
        y: workArea.y,
        width: width,
        height: workArea.height
    };
}

function getVisibleWindowPosition() {
    const display = screen.getPrimaryDisplay();
    const { workArea } = display;
    
    const width = config.width || 400;
    const side = config.side || 'right';
    
    let x;
    if (side === 'right') {
        x = workArea.x + workArea.width - width;
    } else {
        x = workArea.x;
    }

    return {
        x: x,
        y: workArea.y,
        width: width,
        height: workArea.height
    };
}

async function slideWindow(show) {
    if (isAnimating || !win) return;
    
    isAnimating = true;
    const targetBounds = show ? getVisibleWindowPosition() : getWindowPosition();
    const steps = 20;
    const duration = 300;
    const stepTime = duration / steps;

    const startBounds = win.getBounds();
    const deltaX = targetBounds.x - startBounds.x;
    const deltaWidth = targetBounds.width - startBounds.width;

    for (let i = 0; i <= steps; i++) {
        await new Promise(resolve => setTimeout(resolve, stepTime));
        if (!win || win.isDestroyed()) break;
        
        const progress = i / steps;
        const currentX = startBounds.x + (deltaX * progress);
        const currentWidth = startBounds.width + (deltaWidth * progress);
        
        win.setBounds({
            x: Math.round(currentX),
            y: targetBounds.y,
            width: Math.round(currentWidth),
            height: targetBounds.height
        });
    }

    if (win && !win.isDestroyed()) {
        win.setBounds(targetBounds);
        if (show) {
            win.showInactive();
        } else if (!config.pinned) {
            win.hide();
        }
    }
    
    isAnimating = false;
}

function toggleWindow() {
    if (!win || win.isDestroyed()) return;
    
    if (win.isVisible()) {
        slideWindow(false);
    } else {
        slideWindow(true);
    }
}

function updateWindowForPinnedState() {
    if (!win || win.isDestroyed()) return;
    
    if (config.pinned) {
        win.setAlwaysOnTop(true);
        slideWindow(true);
    } else {
        win.setAlwaysOnTop(false);
        if (win.isVisible()) {
            slideWindow(false);
        }
    }
}

function togglePinned() {
    config.pinned = !config.pinned;
    saveConfig({ pinned: config.pinned });
    updateWindowForPinnedState();
    updateTrayMenu();
}

function toggleSide() {
    config.side = config.side === 'right' ? 'left' : 'right';
    saveConfig({ side: config.side });
    if (win && !win.isDestroyed()) {
        win.hide();
        setTimeout(() => {
            const newBounds = getWindowPosition();
            win.setBounds(newBounds);
            if (config.pinned) {
                slideWindow(true);
            }
        }, 100);
    }
}

function setupGlobalShortcuts() {
    globalShortcut.register('Backspace', () => {
        toggleWindow();
    });
}

async function createWindow() {
    const configUrl = await fetchConfig();
    if (!configUrl) {
        showConnectionError();
        return;
    }

    config = loadConfig();
    const initialBounds = getWindowPosition();

    win = new BrowserWindow({
        width: initialBounds.width,
        height: initialBounds.height,
        x: initialBounds.x,
        y: initialBounds.y,
        autoHideMenuBar: true,
        icon: path.join(__dirname, 'NuroIcon.ico'),
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
            enableRemoteModule: false,
            webSecurity: true
        },
        show: false,
        minWidth: 300,
        maxWidth: 800,
        minHeight: initialBounds.height,
        maxHeight: initialBounds.height,
        titleBarStyle: 'hidden',
        frame: false,
        backgroundColor: '#000000',
        alwaysOnTop: config.pinned || false,
        resizable: true,
        movable: false,
        skipTaskbar: true
    });

    win.loadURL(configUrl);

    win.webContents.on("did-finish-load", () => {
        win.webContents.insertCSS(`
            html, body {
                overflow: hidden !important;
                overscroll-behavior: none !important;
                margin: 0 !important;
                padding: 0 !important;
                height: 100vh !important;
            }
            
            body::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                height: 30px;
                background: transparent;
                -webkit-app-region: drag;
                z-index: 10000;
            }
        `);

        if (config.pinned) {
            slideWindow(true);
        }
    });

    win.webContents.on('did-fail-load', () => {
        showConnectionError();
    });

    win.on("close", (event) => {
        if (!app.isQuitting) {
            event.preventDefault();
            win.hide();
        }
    });

    win.on('blur', () => {
        if (!config.pinned && win.isVisible()) {
            setTimeout(() => {
                if (win && !win.isDestroyed() && !win.isFocused()) {
                    slideWindow(false);
                }
            }, 100);
        }
    });

    win.on('resize', () => {
        const bounds = win.getBounds();
        if (bounds.width !== config.width) {
            config.width = bounds.width;
            saveConfig({ width: bounds.width });
            
            if (win.isVisible()) {
                const visiblePos = getVisibleWindowPosition();
                win.setBounds(visiblePos);
            }
        }
    });

    setupGlobalShortcuts();
}

function createTray() {
    if (tray) {
        tray.destroy();
    }

    tray = new Tray(createTrayIcon());

    const contextMenu = Menu.buildFromTemplate([
        {
            label: 'Запускать при запуске системы',
            type: 'checkbox',
            checked: config.runAtStartup || false,
            click: (menuItem) => {
                setAutoLaunch(menuItem.checked);
            }
        },
        {
            label: 'Закрывать автоматически',
            type: 'checkbox',
            checked: !config.pinned,
            click: () => {
                togglePinned();
            }
        },
        {
            label: 'Показать приложение',
            submenu: [
                {
                    label: 'Справа',
                    type: 'radio',
                    checked: config.side === 'right',
                    click: () => {
                        if (config.side !== 'right') {
                            toggleSide();
                        }
                    }
                },
                {
                    label: 'Слева',
                    type: 'radio',
                    checked: config.side === 'left',
                    click: () => {
                        if (config.side !== 'left') {
                            toggleSide();
                        }
                    }
                }
            ]
        },
        { type: 'separator' },
        {
            label: 'Проверить обновления',
            click: () => {
                checkForUpdates();
            }
        },
        { type: 'separator' },
        {
            label: 'Выйти',
            click: () => {
                app.isQuitting = true;
                app.quit();
            }
        }
    ]);

    tray.setToolTip('Nuro');
    tray.setContextMenu(contextMenu);

    tray.on('click', () => {
        toggleWindow();
    });
}

function updateTrayMenu() {
    const contextMenu = Menu.buildFromTemplate([
        {
            label: 'Запускать при запуске системы',
            type: 'checkbox',
            checked: config.runAtStartup || false,
            click: (menuItem) => {
                setAutoLaunch(menuItem.checked);
            }
        },
        {
            label: 'Закрывать автоматически',
            type: 'checkbox',
            checked: !config.pinned,
            click: () => {
                togglePinned();
            }
        },
        {
            label: 'Показать приложение',
            submenu: [
                {
                    label: 'Справа',
                    type: 'radio',
                    checked: config.side === 'right',
                    click: () => {
                        if (config.side !== 'right') {
                            toggleSide();
                        }
                    }
                },
                {
                    label: 'Слева',
                    type: 'radio',
                    checked: config.side === 'left',
                    click: () => {
                        if (config.side !== 'left') {
                            toggleSide();
                        }
                    }
                }
            ]
        },
        { type: 'separator' },
        {
            label: 'Проверить обновления',
            click: () => {
                checkForUpdates();
            }
        },
        { type: 'separator' },
        {
            label: 'Выйти',
            click: () => {
                app.isQuitting = true;
                app.quit();
            }
        }
    ]);

    tray.setContextMenu(contextMenu);
}

const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
    app.quit();
} else {
    app.on('second-instance', () => {
        if (win) {
            if (win.isDestroyed()) {
                createWindow();
            } else {
                slideWindow(true);
            }
        }
    });
}

app.whenReady().then(async () => {
    config = loadConfig();
    if (config.runAtStartup) {
        setAutoLaunch(true);
    }
    
    await checkForUpdates(true);
    createWindow();
    createTray();
});

app.on("window-all-closed", (event) => {
    event.preventDefault();
});

app.on('before-quit', () => {
    app.isQuitting = true;
    globalShortcut.unregisterAll();
});

app.on('will-quit', () => {
    globalShortcut.unregisterAll();
});
