const { app, BrowserWindow, Tray, Menu, screen, net, dialog, nativeImage, Notification } = require('electron');
const path = require('path');
const fs = require('fs');

let win;
let tray;
let config = {};

app.name = 'Nuro';

const configPath = path.join(app.getPath('userData'), 'config.json');

function loadConfig() {
    try {
        if (fs.existsSync(configPath)) {
            const configData = fs.readFileSync(configPath, 'utf8');
            return JSON.parse(configData);
        }
    } catch (error) {
        console.error('Error loading config:', error);
    }
    return {};
}

function saveConfig(newConfig) {
    try {
        config = { ...config, ...newConfig };
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    } catch (error) {
        console.error('Error saving config:', error);
    }
}

function createTrayIcon() {
    const image = nativeImage.createFromPath(path.join(__dirname, 'Nuro-Icon2.ico'));
    return image.resize({ width: 16, height: 16 });
}

function fetchConfig() {
    return new Promise((resolve) => {
        const request = net.request('https://raw.githubusercontent.com/ECCSco/Nuro_Configuration/refs/heads/main/config.json');
        request.on('response', (response) => {
            let data = '';
            response.on('data', (chunk) => {
                data += chunk;
            });
            response.on('end', () => {
                resolve(data.trim());
            });
        });
        request.on('error', () => resolve(null));
        request.end();
    });
}

function fetchURL(url) {
    return new Promise((resolve) => {
        const request = net.request(url);
        request.on('response', (response) => {
            let data = '';
            response.on('data', (chunk) => {
                data += chunk;
            });
            response.on('end', () => {
                resolve(data.trim());
            });
        });
        request.on('error', () => resolve(null));
        request.end();
    });
}

function showConnectionError() {
    dialog.showMessageBoxSync({
        type: 'error',
        title: 'Ошибка подключения',
        message: 'Сервис временно недоступен',
        detail: 'Приносим извинения за неудобства. Пожалуйста, повторите попытку позже.',
        buttons: ['Ок'],
        defaultId: 0,
        noLink: true,
        icon: path.join(__dirname, 'NuroIcon.ico')
    });
    
    app.isQuitting = true;
    app.quit();
}

function initializeDowngradeFolder() {
    const mainJsPath = path.join(process.resourcesPath, 'app', 'main.js');
    const downgradeFolder = path.join(process.resourcesPath, 'app', 'downgrade.js');
    const downgradePath = path.join(downgradeFolder, 'main.js');
    
    if (!fs.existsSync(downgradeFolder)) {
        fs.mkdirSync(downgradeFolder, { recursive: true });
    }
    
    if (fs.existsSync(mainJsPath) && !fs.existsSync(downgradePath)) {
        const currentContent = fs.readFileSync(mainJsPath, 'utf8');
        fs.writeFileSync(downgradePath, currentContent);
    }
}

async function checkForUpdates(silent = false) {
    try {
        const mainJsPath = path.join(process.resourcesPath, 'app', 'main.js');
        const downgradeFolder = path.join(process.resourcesPath, 'app', 'downgrade.js');
        const downgradePath = path.join(downgradeFolder, 'main.js');
        
        if (!fs.existsSync(mainJsPath)) return false;

        const currentContent = fs.readFileSync(mainJsPath, 'utf8');
        const githubContent = await fetchURL('https://raw.githubusercontent.com/ECCSco/Nuro_Configuration/refs/heads/main/AU.json');

        if (githubContent && currentContent !== githubContent) {
            if (!fs.existsSync(downgradeFolder)) {
                fs.mkdirSync(downgradeFolder, { recursive: true });
            }
            
            fs.writeFileSync(downgradePath, currentContent);
            fs.writeFileSync(mainJsPath, githubContent);
            
            if (!silent) {
                new Notification({
                    title: 'Nuro',
                    body: 'Программа была успешно обновлена'
                }).show();
            }
            
            app.relaunch();
            app.exit();
            return true;
        } else if (!silent) {
            new Notification({
                title: 'Nuro',
                body: 'Обновлений не найдено'
            }).show();
        }
    } catch (error) {
        console.error('Error checking for updates:', error);
        if (!silent) {
            new Notification({
                title: 'Nuro',
                body: 'Не удалось проверить обновления'
            }).show();
        }
    }
    return false;
}

async function downgradeApp() {
    try {
        const mainJsPath = path.join(process.resourcesPath, 'app', 'main.js');
        const downgradePath = path.join(process.resourcesPath, 'app', 'downgrade.js', 'main.js');
        
        if (fs.existsSync(downgradePath)) {
            const downgradeContent = fs.readFileSync(downgradePath, 'utf8');
            fs.writeFileSync(mainJsPath, downgradeContent);
            
            new Notification({
                title: 'Nuro',
                body: 'Приложение было возвращено на предыдущую версию'
            }).show();
            
            app.relaunch();
            app.exit();
            return true;
        } else {
            new Notification({
                title: 'Nuro',
                body: 'Файл для отката не найден'
            }).show();
        }
    } catch (error) {
        console.error('Error downgrading app:', error);
        new Notification({
            title: 'Nuro',
            body: 'Не удалось выполнить откат'
        }).show();
    }
    return false;
}

function setAutoLaunch(value) {
    app.setLoginItemSettings({
        openAtLogin: value,
        path: app.getPath('exe')
    });
    saveConfig({ runAtStartup: value });
}

async function createWindow() {
    const configUrl = await fetchConfig();
    if (!configUrl) {
        showConnectionError();
        return;
    }

    config = loadConfig();
    const savedBounds = config.windowBounds || {};

    const cursorPoint = screen.getCursorScreenPoint();
    const display = screen.getDisplayNearestPoint(cursorPoint);
    const { workArea } = display;
    
    const width = savedBounds.width || 800;
    const height = savedBounds.height || 600;
    
    const winX = savedBounds.x || workArea.x + Math.max(0, (workArea.width - width) / 2);
    const winY = savedBounds.y || workArea.y + Math.max(0, (workArea.height - height) / 2);

    win = new BrowserWindow({
        width: width,
        height: height,
        x: winX,
        y: winY,
        autoHideMenuBar: true,
        icon: path.join(__dirname, 'NuroIcon.ico'),
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
            enableRemoteModule: false,
            webSecurity: true
        },
        show: false,
        opacity: 0,
        minWidth: 500,
        minHeight: 400,
        titleBarStyle: 'hidden',
        frame: false,
        backgroundColor: '#000000'
    });

    if (config.isFullScreen) {
        win.setFullScreen(true);
    }
    
    if (config.isAlwaysOnTop) {
        win.setAlwaysOnTop(true);
    }

    win.loadURL(configUrl);

    win.webContents.on("did-finish-load", () => {
        win.webContents.insertCSS(`
            html, body {
                overflow: hidden !important;
                overscroll-behavior: none !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            .drag-handle {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                height: 30px;
                background: transparent;
                -webkit-app-region: drag;
                z-index: 10000;
            }
            
            body {
                margin-top: 30px !important;
                height: calc(100vh - 30px) !important;
                overflow: auto !important;
            }
            
            #app, .app, .container, .root, [data-reactroot], [id*='root'], [class*='root'] {
                margin-top: 0 !important;
            }
        `);

        win.webContents.executeJavaScript(`
            if (!document.querySelector('.drag-handle')) {
                const dragHandle = document.createElement('div');
                dragHandle.className = 'drag-handle';
                document.body.appendChild(dragHandle);
                
                const originalHeight = document.body.style.height;
                const originalMargin = document.body.style.marginTop;
                
                document.body.style.marginTop = '30px';
                document.body.style.height = 'calc(100vh - 30px)';
                
                const appContainers = [
                    document.getElementById('app'),
                    document.getElementById('root'),
                    document.querySelector('.app'),
                    document.querySelector('.container'),
                    document.querySelector('[data-reactroot]'),
                    document.querySelector('[id*="root"]'),
                    document.querySelector('[class*="root"]'),
                    document.querySelector('body > div:first-child')
                ];
                
                for (const container of appContainers) {
                    if (container && container.style) {
                        container.style.marginTop = '0';
                        container.style.height = '100%';
                    }
                }
            }
        `).catch(() => {});
        
        win.show();
        let opacity = 0;
        const fadeInInterval = setInterval(() => {
            opacity += 0.04;
            win.setOpacity(opacity);
            
            if (opacity >= 1) {
                clearInterval(fadeInInterval);
                win.focus();
            }
        }, 30);
    });

    win.webContents.on('did-fail-load', () => {
        showConnectionError();
    });

    win.on("close", (event) => {
        if (!app.isQuitting) {
            event.preventDefault();
            win.hide();
        }
    });

    win.on('resize', () => {
        if (win && !win.isDestroyed() && !win.isMaximized() && !win.isMinimized() && !win.isFullScreen()) {
            const bounds = win.getBounds();
            saveConfig({ windowBounds: bounds });
        }
    });

    win.on('move', () => {
        if (win && !win.isDestroyed() && !win.isMaximized() && !win.isMinimized() && !win.isFullScreen()) {
            const bounds = win.getBounds();
            saveConfig({ windowBounds: bounds });
        }
    });

    win.on('enter-full-screen', () => {
        saveConfig({ isFullScreen: true });
        win.webContents.executeJavaScript(`
            document.querySelector('.drag-handle').style.display = 'none';
            document.body.style.marginTop = '0';
            document.body.style.height = '100vh';
        `).catch(() => {});
    });

    win.on('leave-full-screen', () => {
        saveConfig({ isFullScreen: false });
        win.webContents.executeJavaScript(`
            document.querySelector('.drag-handle').style.display = 'block';
            document.body.style.marginTop = '30px';
            document.body.style.height = 'calc(100vh - 30px)';
        `).catch(() => {});
    });
}

function createTray() {
    if (tray) {
        tray.destroy();
    }

    tray = new Tray(createTrayIcon());

    const contextMenu = Menu.buildFromTemplate([
        {
            label: 'Запускать при запуске системы',
            type: 'checkbox',
            checked: config.runAtStartup || false,
            click: (menuItem) => {
                setAutoLaunch(menuItem.checked);
            }
        },
        {
            label: 'Поверх окон',
            type: 'checkbox',
            checked: config.isAlwaysOnTop || false,
            click: () => {
                toggleAlwaysOnTop();
            }
        },
        { type: 'separator' },
        {
            label: 'Проверить обновления',
            click: () => {
                checkForUpdates();
            }
        },
        {
            label: 'Откат обновлений',
            click: () => {
                downgradeApp();
            }
        },
        { type: 'separator' },
        {
            label: 'Выйти',
            click: () => {
                app.isQuitting = true;
                app.quit();
            }
        }
    ]);

    tray.setToolTip('Nuro');
    tray.setContextMenu(contextMenu);

    tray.on('click', () => {
        if (win && !win.isDestroyed() && win.isVisible()) {
            win.hide();
        } else {
            showWindow();
        }
    });
}

function toggleAlwaysOnTop() {
    const newValue = !config.isAlwaysOnTop;
    saveConfig({ isAlwaysOnTop: newValue });
    
    if (win && !win.isDestroyed()) {
        win.setAlwaysOnTop(newValue);
    }
    
    updateTrayMenu();
}

function updateTrayMenu() {
    const contextMenu = Menu.buildFromTemplate([
        {
            label: 'Запускать при запуске системы',
            type: 'checkbox',
            checked: config.runAtStartup || false,
            click: (menuItem) => {
                setAutoLaunch(menuItem.checked);
            }
        },
        {
            label: 'Поверх окон',
            type: 'checkbox',
            checked: config.isAlwaysOnTop || false,
            click: () => {
                toggleAlwaysOnTop();
            }
        },
        { type: 'separator' },
        {
            label: 'Проверить обновления',
            click: () => {
                checkForUpdates();
            }
        },
        {
            label: 'Откат обновлений',
            click: () => {
                downgradeApp();
            }
        },
        { type: 'separator' },
        {
            label: 'Выйти',
            click: () => {
                app.isQuitting = true;
                app.quit();
            }
        }
    ]);

    tray.setContextMenu(contextMenu);
}

function showWindow() {
    if (win) {
        if (win.isDestroyed()) {
            createWindow();
            return;
        }
        
        const cursorPoint = screen.getCursorScreenPoint();
        const display = screen.getDisplayNearestPoint(cursorPoint);
        const { workArea } = display;
        
        const winBounds = win.getBounds();
        const maxWidth = Math.min(winBounds.width, workArea.width - 40);
        const maxHeight = Math.min(winBounds.height, workArea.height - 40);
        
        const winX = workArea.x + Math.max(0, (workArea.width - maxWidth) / 2);
        const winY = workArea.y + Math.max(0, (workArea.height - maxHeight) / 2);
        
        win.setBounds({
            x: winX,
            y: winY,
            width: maxWidth,
            height: maxHeight
        });
        
        win.show();
        win.focus();
    } else {
        createWindow();
    }
}

const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
    app.quit();
} else {
    app.on('second-instance', () => {
        showWindow();
    });
}

app.whenReady().then(async () => {
    config = loadConfig();
    if (config.runAtStartup) {
        setAutoLaunch(true);
    }
    
    initializeDowngradeFolder();
    await checkForUpdates(true);
    createWindow();
    createTray();
});

app.on("window-all-closed", (event) => {
    event.preventDefault();
});

app.on('before-quit', () => {
    app.isQuitting = true;
    
    if (win && !win.isDestroyed()) {
        const bounds = win.getBounds();
        saveConfig({ windowBounds: bounds });
    }
});
